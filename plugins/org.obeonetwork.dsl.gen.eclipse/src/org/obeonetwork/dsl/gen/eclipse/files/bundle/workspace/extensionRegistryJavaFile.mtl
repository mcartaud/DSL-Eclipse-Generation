[comment encoding = UTF-8 

Copyright (c) 2012 Obeo
All rights reserved.  This program and the accompanying materials
are made available under the terms of the Eclipse Public License 1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

You can apply any license to the files generated with this module and Acceleo.

Contributors :
	Mathieu Cartaud (Obeo) - initial API and implementation
/]
[module extensionRegistryJavaFile('http://www.obeonetwork.org/dsl/eclipse')]

[import org::obeonetwork::dsl::gen::eclipse::common::normalizeName /]

[template private extensionRegistryJavaFile(anExtensionPoint : ExtensionPointProvider)]
[anExtensionPoint.eContainer(Bundle).genBundleJavaPath()/]/registry/[anExtensionPoint.genExtensionName().toLowerFirst()/]/[anExtensionPoint.genExtensionName()/]ExtensionRegistry.java
[/template]

[template public genExtensionRegistryJavaFile(anExtensionPoint : ExtensionPointProvider)]
[file (extensionRegistryJavaFile(), false, 'UTF-8')]
package [anExtensionPoint.ancestors(Bundle).genBundleID()/].registry.[anExtensionPoint.genExtensionName().toLowerFirst()/];

import java.util.ArrayList;
import java.util.List;

/**
 * This will contain all [anExtensionPoint.name/] extension that have been parsed from the extension point.
 * 
 */
public class [anExtensionPoint.genExtensionName()/]ExtensionRegistry {
	/** List of extensions created from the extension point contributions. */
	private static final List<[anExtensionPoint.genExtensionName()/]ExtensionDescriptor> EXTENSIONS = new ArrayList<[anExtensionPoint.genExtensionName()/]ExtensionDescriptor>();

	/**
	 * Utility classes don't need a default constructor.
	 */
	private [anExtensionPoint.genExtensionName()/]ExtensionRegistry() {
		// hides constructor
	}

	/**
	 * Adds an extension to the registry.
	 * 
	 * @param extension
	 *            The extension that is to be added to the registry.
	 */
	public static void addExtension([anExtensionPoint.genExtensionName()/]ExtensionDescriptor extension) {
		EXTENSIONS.add(extension);
	}

	/**
	 * Removes all extensions from the registry. This will be called at plugin stopping.
	 */
	public static void clearRegistry() {
		EXTENSIONS.clear();
	}

	/**
	 * Returns a copy of the registered extensions list.
	 * 
	 * @return A copy of the registered extensions list.
	 */
	public static List<[anExtensionPoint.genExtensionName()/]ExtensionDescriptor> getRegisteredExtensions() {
		return new ArrayList<[anExtensionPoint.genExtensionName()/]ExtensionDescriptor>(EXTENSIONS);
	}

	/**
	 * Removes a phantom from the registry.
	 * 
	 * @param syncElementClassName
	 *            Qualified class name of the sync element which corresponding phantom is to be removed from
	 *            the registry.
	 */
	public static void removeExtension(String extensionClassName) {
		for ([anExtensionPoint.genExtensionName()/]ExtensionDescriptor extension : getRegisteredExtensions()) {
			if (extension.getExtension[anExtensionPoint.className.toUpperFirst()/]().equals(extensionClassName)) {
				EXTENSIONS.remove(extension);
			}
		}
	}
}
[/file]
[/template]